<?xml version="1.0" encoding="utf-8" ?>
<docs>
	<doc for="Container">
		<summary>
			Main container class for components, supporting container hierarchies and
			lifetime management of <see cref="IDisposable"/> instances.
		</summary>
	</doc>
	<doc for="Container.ctor">
		<summary>
			Initializes a new empty container.
		</summary>
	</doc>
	<doc for="Container.DefaultOwner">
		<summary>
			Default owner for new registrations. <see cref="Owner.Container"/> by default.
		</summary>
	</doc>
	<doc for="Container.DefaultReuse">
		<summary>
			Default reuse scope for new registrations. <see cref="ReuseScope.Hierarchy"/> by default.
		</summary>
	</doc>
	<doc for="Container.CreateChildContainer">
		<summary>
			Creates a child container of the current one, which exposes its
			current service registration to the new child container.
		</summary>
	</doc>
	<doc for="Container.Dispose">
		<summary>
			Disposes the container and all instances owned by it (see
			<see cref="Owner.Container"/>), as well as all child containers
			created through <see cref="CreateChildContainer"/>.
		</summary>
	</doc>

	<doc for="Container.Register(instance)">
		<summary>
			Registers a service instance with the container. This instance 
			will have <see cref="Owner.External" /> and <see cref="ReuseScope.Hierarchy"/> 
			behavior.
		</summary>
		<param name="instance">Service instance to use.</param>
	</doc>
	<doc for="Container.Register(name, instance)">
		<summary>
			Registers a named service instance with the container. This instance
			will have <see cref="Owner.External" /> and <see cref="ReuseScope.Hierarchy"/>
			behavior.
		</summary>
		<param name="name">Name of the service to register.</param>
		<param name="instance">Service instance to use.</param>
	</doc>

	<!-- LazyResolve -->
	<doc for="Container.LazyResolve{TService}">
		<summary>
			Retrieves a function that can be used to lazily resolve an instance 
			of the service when needed.
		</summary>
		<typeparam name="TService">Type of the service to retrieve.</typeparam>
		<returns>The function that can resolve to the service instance when invoked.</returns>
		<exception cref="ResolutionException">The requested service has not been registered previously.</exception>
	</doc>
	<doc for="Container.LazyResolveNamed{TService, name}">
		<summary>
			Retrieves a function that can be used to lazily resolve an instance
			of the service with the given name when needed.
		</summary>
		<typeparam name="TService">Type of the service to retrieve.</typeparam>
		<param name="name">Name of the service to retrieve.</param>
		<returns>The function that can resolve to the service instance with the given name when invoked.</returns>
		<exception cref="ResolutionException">The requested service with the given name has not been registered previously.</exception>
	</doc>
	<doc for="Container.LazyResolve{TService, TArgs, name}">
		<summary>
			Retrieves a function that can be used to lazily resolve an instance
			of the service of the given type, name and service constructor arguments when needed.
		</summary>
		<param name="name">Name of the service to retrieve.</param>
		<returns>The function that can resolve to the service instance with the given and service constructor arguments name when invoked.</returns>
		<exception cref="ResolutionException">The requested service with the given name and constructor arguments has not been registered previously.</exception>
	</doc>

	<!-- Resolve -->
	<doc for="Container.Resolve{TService}">
		<summary>
			Resolves the given service by type, without passing any arguments for
			its construction.
		</summary>
		<typeparam name="TService">Type of the service to retrieve.</typeparam>
		<returns>The resolved service instance.</returns>
		<exception cref="ResolutionException">The given service could not be resolved.</exception>
	</doc>
	<doc for="Container.Resolve{TService, TArg}">
		<summary>
			Resolves the given service by type, passing the given arguments
			for its initialization.
		</summary>
		<typeparam name="TService">Type of the service to retrieve.</typeparam>
		<typeparam name="TArg">First argument to pass to the factory delegate that may create the instace.</typeparam>
		<returns>The resolved service instance.</returns>
		<exception cref="ResolutionException">The given service could not be resolved.</exception>
	</doc>

	<!-- ResolveNamed -->
	<doc for="Container.ResolveNamed{TService}">
		<summary>
			Resolves the given service by type and name, without passing arguments for its initialization.
		</summary>
		<typeparam name="TService">Type of the service to retrieve.</typeparam>
		<returns>The resolved service instance.</returns>
		<exception cref="ResolutionException">The given service could not be resolved.</exception>
	</doc>
	<doc for="Container.ResolveNamed{TService, TArg}">
		<summary>
			Resolves the given service by type and name, passing the given arguments
			for its initialization.
		</summary>
		<typeparam name="TService">Type of the service to retrieve.</typeparam>
		<typeparam name="TArg">First argument to pass to the factory delegate that may create the instace.</typeparam>
		<returns>The resolved service instance.</returns>
	</doc>
	
	<!-- TryResolve -->
	<doc for="Container.TryResolve{TService}">
		<summary>
			Attempts to resolve the given service by type, without passing arguments for its initialization.
		</summary>
		<typeparam name="TService">Type of the service to retrieve.</typeparam>
		<returns>
			The resolved service instance or <see langword="null"/> if it cannot be resolved.
		</returns>
	</doc>
	<doc for="Container.TryResolve{TService, TArg}">
		<summary>
			Attempts to resolve the given service by type, passing the
			given arguments arguments for its initialization.
		</summary>
		<typeparam name="TService">Type of the service to retrieve.</typeparam>
		<typeparam name="TArg">First argument to pass to the factory delegate that may create the instace.</typeparam>
		<returns>
			The resolved service instance or <see langword="null"/> if it cannot be resolved.
		</returns>
	</doc>

	<!-- TryResolveNamed -->
	<doc for="Container.TryResolveNamed{TService}">
		<summary>
			Attempts to resolve the given service by type and name, without passing
			arguments arguments for its initialization.
		</summary>
		<typeparam name="TService">Type of the service to retrieve.</typeparam>
		<returns>
			The resolved service instance or <see langword="null"/> if it cannot be resolved.
		</returns>
	</doc>
	<doc for="Container.TryResolveNamed{TService, TArg}">
		<summary>
			Attempts to resolve the given service by type and name, passing the
			given arguments arguments for its initialization.
		</summary>
		<typeparam name="TService">Type of the service to retrieve.</typeparam>
		<typeparam name="TArg">First argument to pass to the factory delegate that may create the instace.</typeparam>
		<returns>
			The resolved service instance or <see langword="null"/> if it cannot be resolved.
		</returns>
	</doc>

	<!-- Register(name, factory) -->
	<doc for="Container.Register{TService}(name, factory)">
		<summary>
			Registers the given named service by providing a factory delegate to
			instantiate it.
		</summary>
		<typeparam name="TService">The service type to register.</typeparam>
		<param name="name">A name used to differenciate this service registration.</param>
		<param name="factory">The factory delegate to initialize new instances of the service when needed.</param>
		<returns>The registration object to perform further configuration via its fluent interface.</returns>
	</doc>
	<doc for="Container.Register{TService, TArg}(name, factory)">
		<summary>
			Registers the given named service by providing a factory delegate that receives arguments to
			instantiate it.
		</summary>
		<typeparam name="TService">The service type to register.</typeparam>
		<typeparam name="TArg">First argument that should be passed to the factory delegate to create the instace.</typeparam>
		<param name="name">A name used to differenciate this service registration.</param>
		<param name="factory">The factory delegate to initialize new instances of the service when needed.</param>
		<returns>The registration object to perform further configuration via its fluent interface.</returns>
	</doc>

	<!-- Register(factory) -->
	<doc for="Container.Register{TService}(factory)">
		<summary>
			Registers the given service by providing a factory delegate to
			instantiate it.
		</summary>
		<typeparam name="TService">The service type to register.</typeparam>
		<param name="factory">The factory delegate to initialize new instances of the service when needed.</param>
		<returns>The registration object to perform further configuration via its fluent interface.</returns>
	</doc>
	<doc for="Container.Register{TService, TArg}(factory)">
		<summary>
			Registers the given service by providing a factory delegate that receives arguments to
			instantiate it.
		</summary>
		<typeparam name="TService">The service type to register.</typeparam>
		<typeparam name="TArg">First argument that should be passed to the factory delegate to create the instace.</typeparam>
		<param name="factory">The factory delegate to initialize new instances of the service when needed.</param>
		<returns>The registration object to perform further configuration via its fluent interface.</returns>
	</doc>

	<doc for="IFluentInterface">
		<summary>
			Helper interface used to hide the base <see cref="Object"/>
			members from the fluent API to make for much cleaner
			Visual Studio intellisense experience.
		</summary>
	</doc>

	<doc for="IFunqlet">
		<summary>
			Funqlets are a set of components provided as a package
			to an existing container (like a module).
		</summary>
	</doc>
	<doc for="IFunqlet.Configure">
		<summary>
			Configure the given container with the registrations provided by the funqlet.
		</summary>
		<param name="container">Container to register.</param>	
	</doc>

	<doc for="Owner">
		<summary>
			Determines who is responsible for disposing instances
			registered with a container.
		</summary>
	</doc>
	<doc for="Owner.Container">
		<summary>
			Container should dispose provided instances when it is disposed.
			This is the default.
		</summary>		
	</doc>
	<doc for="Owner.External">
		<summary>
			Container does not dispose provided instances.
		</summary>
	</doc>
	<doc for="Owner.Default">
		<summary>
			Default owner, which equals <see cref="Container"/>.
		</summary>
	</doc>

	<doc for="ResolutionException">
		<summary>
			Exception thrown by the container when a service cannot be resolved.
		</summary>
	</doc>
	<doc for="ResolutionException.ctor(Type)">
		<summary>
			Initializes the exception with the service that could not be resolved.
		</summary>
	</doc>
	<doc for="ResolutionException.ctor(Type, string)">
		<summary>
			Initializes the exception with the service (and its name) that could not be resolved.
		</summary>
	</doc>
	<doc for="ResolutionException.ctor(string)">
		<summary>
			Initializes the exception with an arbitrary message.
		</summary>
	</doc>

	<doc for="ReuseScope">
		<summary>
			Determines visibility and reuse of instances provided by the container.
		</summary>
	</doc>
	<doc for="ReuseScope.Container">
		<summary>
			Instances are reused only at the given container. Descendent
			containers do not reuse parent container instances and get
			a new instance at their level.
		</summary>
	</doc>
	<doc for="ReuseScope.Hierarchy">
		<summary>
			Instances are reused within a container hierarchy. Instances
			are created (if necessary) in the container where the registration
			was performed, and are reused by all descendent containers.
		</summary>
	</doc>
	<doc for="ReuseScope.None">
		<summary>
			Each request to resolve the dependency will result in a new
			instance being returned.
		</summary>
	</doc>
	<doc for="ReuseScope.Default">
		<summary>
			Default scope, which equals <see cref="Hierarchy"/>.
		</summary>
	</doc>

	<!-- Syntax -->
	<doc for="IRegistration">
		<summary>
			Fluent API for customizing the registration of a service.
		</summary>
	</doc>
	<doc for="IRegistration{TService}">
		<summary>
			Fluent API for customizing the registration of a service.
		</summary>
	</doc>
	<doc for="IInitializable">
		<summary>
			Fluent API that allows registering an initializer for the
			service.
		</summary>
	</doc>
	<doc for="IInitializable.InitializedBy">
		<summary>
			Specifies an initializer that should be invoked after
			the service instance has been created by the factory.
		</summary>
	</doc>
	<doc for="IReusedOwned">
		<summary>
			Fluent API that exposes both <see cref="IReused.ReusedWithin"/>
			and owner (<see cref="IOwned.OwnedBy"/>).
		</summary>
	</doc>
	<doc for="IReused">
		<summary>
			Fluent API that allows specifying the reuse instances.
		</summary>
	</doc>
	<doc for="IReused.ReusedWithin">
		<summary>
			Specifies how instances are reused within a container or hierarchy. Default
			scope is <see cref="ReuseScope.Hierarchy"/>.
		</summary>
	</doc>
	<doc for="IOwned">
		<summary>
			Fluent API that allows specifying the owner of instances
			created from a registration.
		</summary>
	</doc>
	<doc for="IOwned.OwnedBy">
		<summary>
			Specifies the owner of instances created from this registration. Default
			owner is <see cref="Owner.Container"/>.
		</summary>
	</doc>
</docs>
